<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rotating Globe with Heatmap</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <canvas id="globeCanvas" width="960" height="500"></canvas>
    <script>
        const width = 960, height = 500;
        const canvas = document.getElementById("globeCanvas");
        const ctx = canvas.getContext("2d");

        // Create orthographic projection for the globe
        const projection = d3.geoOrthographic()
            .scale(250)  // Adjust size of the globe
            .translate([width / 2, height / 2])
            .clipAngle(90);

        const path = d3.geoPath().projection(projection).context(ctx);
        const sphere = { type: "Sphere" };  // Represents the Earth

        let rotation = [0, 0];
        let dragging = false;
        let lastPos = null;
        let animationFrame = null;

        function drawGlobe() {
            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            path(sphere);
            ctx.strokeStyle = "black";
            ctx.stroke();

            // Draw heatmap only if data is available
            if (fluxArray && latArray && lonArray) {
                let index = 0;
                for (let latIdx = 0; latIdx < latArray.length; latIdx++) {
                    for (let lonIdx = 0; lonIdx < lonArray.length; lonIdx++) {
                        const value = fluxArray[index];
                        index++;
                        if (!isNaN(value)) {
                            const normalizedValue = (value - vmin) / range;
                            ctx.fillStyle = colorScale(normalizedValue);
                            const [x, y] = projection([lonArray[lonIdx], latArray[latIdx]]);
                            ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            }
        }

        function rotateGlobe(event) {
            if (!dragging) return;
            const [x, y] = [event.offsetX, event.offsetY];
            if (lastPos) {
                const dx = x - lastPos[0], dy = y - lastPos[1];
                rotation[0] += dx * 0.2;  // Reduce multiplier for smoother rotation
                rotation[1] -= dy * 0.2;
                projection.rotate(rotation);
                if (!animationFrame) {
                    animationFrame = requestAnimationFrame(() => {
                        drawGlobe();
                        animationFrame = null;
                    });
                }
            }
            lastPos = [x, y];
        }

        canvas.addEventListener("mousedown", (event) => {
            dragging = true;
            lastPos = [event.offsetX, event.offsetY];
        });

        canvas.addEventListener("mousemove", rotateGlobe);
        canvas.addEventListener("mouseup", () => dragging = false);
        canvas.addEventListener("mouseleave", () => dragging = false);

        // Fetch and draw heatmap data
        async function loadBinData(url) {
            const response = await fetch(url);
            const buffer = await response.arrayBuffer();
            return new Float32Array(buffer); // Convert binary data to Float32Array
        }

        let fluxArray, latArray, lonArray, vmin, vmax, range, colorScale;

        Promise.all([
            loadBinData("/heatmap-data/lat.bin"),
            loadBinData("/heatmap-data/lon.bin"),
            loadBinData("/heatmap-data/fluxes.bin"),
        ]).then(([latData, lonData, fluxData]) => {
            latArray = latData;
            lonArray = lonData;
            fluxArray = fluxData;

            console.log("Loaded Data.");
            vmin = d3.min(fluxArray.filter(v => v < 0));
            vmax = d3.max(fluxArray.filter(v => v < 0));
            range = vmax - vmin || 1;

            colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([0, 1]);
            drawGlobe();
        }).catch(error => console.error("Error loading binary data:", error));
    </script>
</body>
</html>